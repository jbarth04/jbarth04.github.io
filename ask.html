<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ask - Josie Astrid Consulting</title>
    <link rel="stylesheet" href="./static/style.css">
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="./index.html" class="nav-brand">
                <img src="./static/JAC_Logo.png" alt="Josie Astrid Consulting" class="nav-logo">
            </a>
            <div class="nav-links">
                <a href="./index.html">Home</a>
                <a href="./ask.html" class="active">Ask</a>
                <a href="./about.html">About</a>
                <a href="./contact.html">Contact</a>
            </div>
            <button class="mobile-menu-btn" aria-label="Menu">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 12H21M3 6H21M3 18H21" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
        </div>
    </nav>

    <main class="main">
        <div class="container">
            <div class="home-content">
                <div class="home-body">
                    <div class="home-text">
                        <h1>Meet my AI twin</h1>
                        <p class="main-paragraph">My Voice AI agent trained on my background and my work, and it even speaks in my own voice. Ask it about how I work with clients and what I can help you solve.</p>
                        <button id="vapi-voice-btn" class="voice-btn">
                            <span class="voice-btn-text">TALK TO MY AI TWIN</span>
                        </button>
                        <canvas id="waveform-canvas" class="waveform-canvas" width="300" height="60" style="display: none;"></canvas>
                        <div id="call-status" class="call-status" style="display: none;">
                            <span class="status-text">Call in progress...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Mobile Menu Overlay -->
    <div class="mobile-menu-overlay">
        <button class="mobile-menu-close" aria-label="Close menu">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
        </button>
        <ul class="mobile-nav-links">
            <li><a href="./index.html">Home</a></li>
            <li><a href="./ask.html" class="active">Ask</a></li>
            <li><a href="./about.html">About</a></li>
            <li><a href="./contact.html">Contact</a></li>
        </ul>
    </div>

    <script src="./config.js"></script>
    <script>
        var vapiInstance = null;
        const assistant = window.SITE_CONFIG?.VAPI_ASSISTANT_ID;
        const apiKey = window.SITE_CONFIG?.VAPI_PUBLIC_KEY;

        (function (d, t) {
            var g = document.createElement(t),
                s = d.getElementsByTagName(t)[0];
            g.src = "https://cdn.jsdelivr.net/gh/VapiAI/html-script-tag@latest/dist/assets/index.js";
            g.defer = true;
            g.async = true;
            s.parentNode.insertBefore(g, s);

            g.onload = function () {
                // Initialize Vapi SDK without creating any widget
                if (window.vapiSDK && window.vapiSDK.Vapi) {
                    vapiInstance = new window.vapiSDK.Vapi({
                        apiKey: apiKey
                    });
                } else {
                    // Fallback to run method but with completely hidden config
                    vapiInstance = window.vapiSDK.run({
                        apiKey: apiKey,
                        assistant: assistant,
                        config: {
                            position: 'bottom-right',
                            offset: '-99999px',
                            width: '0px',
                            height: '0px',
                            idle: { color: 'rgba(0,0,0,0)', display: 'none' },
                            loading: { color: 'rgba(0,0,0,0)', display: 'none' },
                            active: { color: 'rgba(0,0,0,0)', display: 'none' }
                        }
                    });
                }
                
                // Add click handler to our custom button
                const customBtn = document.getElementById('vapi-voice-btn');
                const waveformCanvas = document.getElementById('waveform-canvas');
                const callStatus = document.getElementById('call-status');
                let isCallActive = false;
                let waveformAnimation = null;
                
                if (customBtn) {
                    customBtn.addEventListener('click', function() {
                        if (vapiInstance) {
                            if (isCallActive) {
                                if (vapiInstance.stop) {
                                    vapiInstance.stop();
                                }
                            } else {
                                if (vapiInstance.start) {
                                    vapiInstance.start(assistant);
                                } else if (vapiInstance.call) {
                                    vapiInstance.call({ assistant: assistant });
                                }
                            }
                        }
                    });
                }
                
                if (vapiInstance) {
                    vapiInstance.on('call-start', () => {
                        console.log('Call started');
                        isCallActive = true;
                        customBtn.setAttribute('data-state', 'active');
                        waveformCanvas.style.display = 'block';
                        callStatus.style.display = 'block';
                        startWaveformAnimation();
                    });
                    
                    vapiInstance.on('call-end', () => {
                        console.log('Call ended');
                        isCallActive = false;
                        customBtn.setAttribute('data-state', '');
                        waveformCanvas.style.display = 'none';
                        callStatus.style.display = 'none';
                        stopWaveformAnimation();
                    });
                    
                    vapiInstance.on('message', (message) => {
                        if (message.type === 'transcript') {
                            console.log(`${message.role}: ${message.transcript}`);
                        }
                    });
                }
                
                function startWaveformAnimation() {
                    const canvas = waveformCanvas;
                    const ctx = canvas.getContext('2d');
                    let time = 0;
                    const numLines = 30; // 30 bars for visual appeal
                    const lineWidth = 3;
                    const spacing = canvas.width / numLines;
                    
                    // Speech-responsive animation system with enhanced smoothing
                    let currentVolume = 0.05; // Start with idle level
                    let hasVolumeData = false;
                    let lastVolumeTime = Date.now();
                    let audioData = new Array(numLines).fill(0.05);
                    let smoothedData = new Array(numLines).fill(0.05);
                    let isTabVisible = true;
                    
                    // Performance optimization: pause animation when tab not visible
                    document.addEventListener('visibilitychange', () => {
                        isTabVisible = !document.hidden;
                    });
                    
                    // Listen to VAPI volume-level events for real-time audio data
                    if (vapiInstance) {
                        vapiInstance.on('volume-level', (volume) => {
                            // Volume comes as a number, normalize and use for animation
                            currentVolume = Math.max(volume / 100, 0.05); // Ensure minimum idle level
                            hasVolumeData = true;
                            lastVolumeTime = Date.now();
                        });
                    }
                    
                    // Audio element detection for fallback
                    function detectAudioPlayback() {
                        const audioElements = document.querySelectorAll('audio, video');
                        let isPlaying = false;
                        let audioLevel = 0.05;
                        
                        audioElements.forEach(element => {
                            if (!element.paused && !element.ended && element.readyState > 2) {
                                isPlaying = true;
                                // Estimate audio level based on element state
                                audioLevel = Math.max(audioLevel, 0.2);
                            }
                        });
                        
                        return { isPlaying, audioLevel };
                    }
                    
                    function updateWaveData() {
                        const now = Date.now();
                        const timeSinceLastVolume = now - lastVolumeTime;
                        
                        // Determine animation source priority
                        let effectiveVolume = currentVolume;
                        let animationMode = 'volume'; // 'volume', 'audio', 'idle'
                        
                        // Check if volume data is stale (no events for 500ms)
                        if (timeSinceLastVolume > 500) {
                            hasVolumeData = false;
                        }
                        
                        // Fallback to audio element detection if no volume data
                        if (!hasVolumeData) {
                            const audioState = detectAudioPlayback();
                            if (audioState.isPlaying) {
                                effectiveVolume = audioState.audioLevel;
                                animationMode = 'audio';
                            } else {
                                animationMode = 'idle';
                            }
                        }
                        
                        // Generate subtle idle pulse for when no speech detected
                        const idlePulse = 0.05 + Math.sin(time * 0.01) * 0.02; // Very subtle idle pulse
                        
                        // Update all bars with speech-responsive animation
                        for (let i = 0; i < numLines; i++) {
                            let targetHeight;
                            
                            if (animationMode === 'volume' || animationMode === 'audio') {
                                // Speech-responsive animation with noticeable height variation
                                
                                // Base speech energy from volume with good amplification for visibility
                                const speechEnergy = effectiveVolume * 3.5; // Strong amplification for clear response
                                
                                // Add organic variation that responds to speech patterns
                                const speechVariation1 = (Math.random() - 0.5) * speechEnergy * 0.4; // Primary variation
                                const speechVariation2 = (Math.random() - 0.5) * speechEnergy * 0.25; // Secondary variation
                                const speechVariation3 = (Math.random() - 0.5) * speechEnergy * 0.15; // Micro-variations
                                
                                // Add slight bar-to-bar correlation for natural flow
                                const neighborInfluence = i > 0 ? (audioData[i-1] - idlePulse) * 0.12 : 0;
                                
                                // Combine speech elements for responsive animation
                                const speechComponent = speechEnergy + speechVariation1 + speechVariation2 + speechVariation3 + neighborInfluence;
                                
                                // Blend with minimal idle component
                                targetHeight = speechComponent * 0.85 + idlePulse * 0.15;
                                
                                // Add momentum for natural speech rhythm
                                if (i > 0) {
                                    const momentum = (audioData[i-1] - idlePulse) * 0.08;
                                    targetHeight += momentum;
                                }
                            } else {
                                // Idle state - subtle, uniform pulse
                                const idleVariation = (Math.random() - 0.5) * 0.01; // Minimal random variation
                                targetHeight = idlePulse + idleVariation;
                            }
                            
                            audioData[i] = Math.max(targetHeight, 0.03); // Minimal floor for visibility
                        }
                        
                        // Enhanced smoothing for fluid movement without jitteriness
                        for (let i = 0; i < numLines; i++) {
                            // Stronger smoothing to eliminate jitter while maintaining responsiveness
                            const smoothingFactor = isTabVisible ? 0.85 : 0.92; // Enhanced smoothing
                            smoothedData[i] = smoothedData[i] * smoothingFactor + audioData[i] * (1 - smoothingFactor);
                        }
                    }
                    
                    function animate() {
                        if (!isCallActive) return;
                        
                        // Performance optimization: reduce frame rate when tab hidden
                        const frameSkip = isTabVisible ? 1 : 3;
                        if (time % frameSkip !== 0) {
                            time++;
                            waveformAnimation = requestAnimationFrame(animate);
                            return;
                        }
                        
                        updateWaveData();
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.strokeStyle = '#111';
                        ctx.lineWidth = lineWidth;
                        ctx.lineCap = 'round';
                        
                        const centerY = canvas.height / 2;
                        const maxHeight = canvas.height * 0.9; // Optimal height for continuous wave animation
                        
                        // Draw all bars with consistent spacing
                        for (let i = 0; i < numLines; i++) {
                            const x = (i + 0.5) * spacing;
                            const height = smoothedData[i] * maxHeight;
                            
                            const startY = centerY - height / 2;
                            const endY = centerY + height / 2;
                            
                            ctx.beginPath();
                            ctx.moveTo(x, startY);
                            ctx.lineTo(x, endY);
                            ctx.stroke();
                        }
                        
                        time++;
                        waveformAnimation = requestAnimationFrame(animate);
                    }
                    
                    // Start animation immediately - volume events will drive responsiveness
                    animate();
                }
                
                function stopWaveformAnimation() {
                    if (waveformAnimation) {
                        cancelAnimationFrame(waveformAnimation);
                        waveformAnimation = null;
                    }
                    
                    const canvas = waveformCanvas;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            };
        })(document, "script");
    </script>
    <script src="./static/app.js"></script>
</body>
</html>
