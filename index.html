<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Josie Astrid Consulting</title>
    <link rel="stylesheet" href="./static/style.css">
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="./index.html" class="nav-brand">
                <img src="./static/JAC_Logo.png" alt="Josie Astrid Consulting" class="nav-logo">
            </a>
            <div class="nav-links">
                <a href="./index.html" class="active">Home</a>
                <a href="./about.html">About</a>
                <a href="./contact.html">Contact</a>
            </div>
            <button class="mobile-menu-btn" aria-label="Menu">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M3 12H21M3 6H21M3 18H21" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
        </div>
    </nav>

    <main class="main">
        <div class="container">
            <div class="home-content">
                <div class="home-body">
                    <div class="home-text">
                        <h1>Welcome to Josie Astrid Consulting</h1>
                        <p class="main-paragraph">Meet my AI twin. It's trained on my background and my work, and it even speaks in my own voice. Ask it about how I work with clients and what I can help you solve.</p>
                        <button id="vapi-voice-btn" class="voice-btn">
                            <span class="voice-btn-text">TALK TO MY AI TWIN</span>
                        </button>
                        <canvas id="waveform-canvas" class="waveform-canvas" width="300" height="60" style="display: none;"></canvas>
                        <div id="call-status" class="call-status" style="display: none;">
                            <span class="status-text">Call in progress...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Mobile Menu Overlay -->
    <div class="mobile-menu-overlay">
        <button class="mobile-menu-close" aria-label="Close menu">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
        </button>
        <ul class="mobile-nav-links">
            <li><a href="./index.html" class="active">Home</a></li>
            <li><a href="./about.html">About</a></li>
            <li><a href="./contact.html">Contact</a></li>
        </ul>
    </div>

    <script>
        var vapiInstance = null;
        const assistant = "eea2ce9f-3124-462f-9a5c-3b6a0a16672b";
        const apiKey = "0cf8ba01-833e-42bc-8bb8-83cf4d3035b8";

        (function (d, t) {
            var g = document.createElement(t),
                s = d.getElementsByTagName(t)[0];
            g.src = "https://cdn.jsdelivr.net/gh/VapiAI/html-script-tag@latest/dist/assets/index.js";
            g.defer = true;
            g.async = true;
            s.parentNode.insertBefore(g, s);

            g.onload = function () {
                // Initialize Vapi SDK without creating any widget
                if (window.vapiSDK && window.vapiSDK.Vapi) {
                    vapiInstance = new window.vapiSDK.Vapi({
                        apiKey: apiKey
                    });
                } else {
                    // Fallback to run method but with completely hidden config
                    vapiInstance = window.vapiSDK.run({
                        apiKey: apiKey,
                        assistant: assistant,
                        config: {
                            position: 'bottom-right',
                            offset: '-99999px',
                            width: '0px',
                            height: '0px',
                            idle: { color: 'rgba(0,0,0,0)', display: 'none' },
                            loading: { color: 'rgba(0,0,0,0)', display: 'none' },
                            active: { color: 'rgba(0,0,0,0)', display: 'none' }
                        }
                    });
                }
                
                // Add click handler to our custom button
                const customBtn = document.getElementById('vapi-voice-btn');
                const waveformCanvas = document.getElementById('waveform-canvas');
                const callStatus = document.getElementById('call-status');
                let isCallActive = false;
                let waveformAnimation = null;
                
                if (customBtn) {
                    customBtn.addEventListener('click', function() {
                        if (vapiInstance) {
                            if (isCallActive) {
                                if (vapiInstance.stop) {
                                    vapiInstance.stop();
                                }
                            } else {
                                if (vapiInstance.start) {
                                    vapiInstance.start(assistant);
                                } else if (vapiInstance.call) {
                                    vapiInstance.call({ assistant: assistant });
                                }
                            }
                        }
                    });
                }
                
                if (vapiInstance) {
                    vapiInstance.on('call-start', () => {
                        console.log('Call started');
                        isCallActive = true;
                        customBtn.setAttribute('data-state', 'active');
                        waveformCanvas.style.display = 'block';
                        callStatus.style.display = 'block';
                        startWaveformAnimation();
                    });
                    
                    vapiInstance.on('call-end', () => {
                        console.log('Call ended');
                        isCallActive = false;
                        customBtn.setAttribute('data-state', '');
                        waveformCanvas.style.display = 'none';
                        callStatus.style.display = 'none';
                        stopWaveformAnimation();
                    });
                    
                    vapiInstance.on('message', (message) => {
                        if (message.type === 'transcript') {
                            console.log(`${message.role}: ${message.transcript}`);
                        }
                    });
                }
                
                function startWaveformAnimation() {
                    const canvas = waveformCanvas;
                    const ctx = canvas.getContext('2d');
                    let time = 0;
                    const numLines = 30; // Increased to 24-32 range as requested
                    const lineWidth = 3;
                    const spacing = canvas.width / numLines;
                    
                    // Multi-layered animation system
                    let currentVolume = 0.1; // Start with idle level
                    let hasVolumeData = false;
                    let lastVolumeTime = Date.now();
                    let audioData = new Array(numLines).fill(0.1);
                    let smoothedData = new Array(numLines).fill(0.1);
                    let isTabVisible = true;
                    
                    // Performance optimization: pause animation when tab not visible
                    document.addEventListener('visibilitychange', () => {
                        isTabVisible = !document.hidden;
                    });
                    
                    // Listen to VAPI volume-level events for real-time audio data
                    if (vapiInstance) {
                        vapiInstance.on('volume-level', (volume) => {
                            // Volume comes as a number, normalize and use for animation
                            currentVolume = Math.max(volume / 100, 0.05); // Ensure minimum idle level
                            hasVolumeData = true;
                            lastVolumeTime = Date.now();
                        });
                    }
                    
                    // Audio element detection for fallback
                    function detectAudioPlayback() {
                        const audioElements = document.querySelectorAll('audio, video');
                        let isPlaying = false;
                        let audioLevel = 0.1;
                        
                        audioElements.forEach(element => {
                            if (!element.paused && !element.ended && element.readyState > 2) {
                                isPlaying = true;
                                // Estimate audio level based on element state
                                audioLevel = Math.max(audioLevel, 0.3);
                            }
                        });
                        
                        return { isPlaying, audioLevel };
                    }
                    
                    function updateAudioData() {
                        const now = Date.now();
                        const timeSinceLastVolume = now - lastVolumeTime;
                        
                        // Determine animation source priority
                        let effectiveVolume = currentVolume;
                        let animationMode = 'volume'; // 'volume', 'audio', 'procedural'
                        
                        // Check if volume data is stale (no events for 500ms)
                        if (timeSinceLastVolume > 500) {
                            hasVolumeData = false;
                        }
                        
                        // Fallback to audio element detection if no volume data
                        if (!hasVolumeData) {
                            const audioState = detectAudioPlayback();
                            if (audioState.isPlaying) {
                                effectiveVolume = audioState.audioLevel;
                                animationMode = 'audio';
                            } else {
                                animationMode = 'procedural';
                            }
                        }
                        
                        // Generate subtle idle pulse for when no speech detected
                        const idlePulse = 0.04 + Math.sin(time * 0.008) * 0.02; // Very subtle idle pulse
                        
                        // Update all bars with speech-pattern-based animation
                        for (let i = 0; i < numLines; i++) {
                            let targetHeight;
                            
                            if (animationMode === 'volume' || animationMode === 'audio') {
                                // Speech-pattern animation that reacts to natural rhythm
                                // Create organic, irregular patterns that mimic speech characteristics
                                
                                // Base speech energy from volume with amplification
                                const speechEnergy = effectiveVolume * 2.8; // Amplify for visibility
                                
                                // Add speech-like irregular patterns instead of uniform waves
                                // Use multiple random frequencies to create organic variation
                                const speechPattern1 = (Math.random() - 0.5) * speechEnergy * 0.4; // Primary speech variation
                                const speechPattern2 = (Math.random() - 0.5) * speechEnergy * 0.25; // Secondary variation
                                const speechPattern3 = (Math.random() - 0.5) * speechEnergy * 0.15; // Micro-variations
                                
                                // Add slight bar-to-bar correlation for more natural flow
                                const neighborInfluence = i > 0 ? (audioData[i-1] - idlePulse) * 0.1 : 0;
                                
                                // Combine all speech elements for organic, human-like animation
                                const speechComponent = speechEnergy + speechPattern1 + speechPattern2 + speechPattern3 + neighborInfluence;
                                
                                // Blend with minimal idle component to prevent complete silence
                                targetHeight = speechComponent * 0.9 + idlePulse * 0.1;
                                
                                // Add slight momentum/decay for more natural speech rhythm
                                if (i > 0) {
                                    const momentum = (audioData[i-1] - idlePulse) * 0.05;
                                    targetHeight += momentum;
                                }
                            } else {
                                // Pure idle state - very subtle, uniform pulse
                                const idleVariation = (Math.random() - 0.5) * 0.005; // Minimal random variation
                                targetHeight = idlePulse + idleVariation;
                            }
                            
                            audioData[i] = Math.max(targetHeight, 0.02); // Minimal floor for visibility
                        }
                        
                        // Smooth the data for fluid movement with gentle easing
                        for (let i = 0; i < numLines; i++) {
                            const smoothingFactor = isTabVisible ? 0.75 : 0.9; // Slower when tab hidden
                            smoothedData[i] = smoothedData[i] * smoothingFactor + audioData[i] * (1 - smoothingFactor);
                        }
                    }
                    
                    function animate() {
                        if (!isCallActive) return;
                        
                        // Performance optimization: reduce frame rate when tab hidden
                        const frameSkip = isTabVisible ? 1 : 3;
                        if (time % frameSkip !== 0) {
                            time++;
                            waveformAnimation = requestAnimationFrame(animate);
                            return;
                        }
                        
                        updateAudioData();
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.strokeStyle = '#111';
                        ctx.lineWidth = lineWidth;
                        ctx.lineCap = 'round';
                        
                        const centerY = canvas.height / 2;
                        const maxHeight = canvas.height * 0.9; // Increased from 0.8 to allow taller bars for better contrast
                        
                        // Draw all bars with consistent spacing
                        for (let i = 0; i < numLines; i++) {
                            const x = (i + 0.5) * spacing;
                            const height = smoothedData[i] * maxHeight;
                            
                            const startY = centerY - height / 2;
                            const endY = centerY + height / 2;
                            
                            ctx.beginPath();
                            ctx.moveTo(x, startY);
                            ctx.lineTo(x, endY);
                            ctx.stroke();
                        }
                        
                        time++;
                        waveformAnimation = requestAnimationFrame(animate);
                    }
                    
                    // Start animation immediately - volume events will drive responsiveness
                    animate();
                }
                
                function stopWaveformAnimation() {
                    if (waveformAnimation) {
                        cancelAnimationFrame(waveformAnimation);
                        waveformAnimation = null;
                    }
                    
                    const canvas = waveformCanvas;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            };
        })(document, "script");
    </script>
    <script src="./config.js"></script>
    <script src="./static/app.js"></script>
</body>
</html>
